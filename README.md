# GoStructural Compression Engines

This repository contains a collection of engines that do not compress data. They critique it. They operate on a cynical principle: that any given string is a clumsy, inefficient, and profoundly redundant expression of a simpler underlying reality. The goal is to shorten the string by discovering its underlying grammar and recording *that*—a far more honest and compact representation than the string itself. The resulting compression is therefore not a statistical trick, but an act of aggressive, philosophical editing.

## 1. Hyper-Geometrisomorphous Engine

This engine performs compression via cosmology. It treats a linear string as a one-dimensional sensory experience of a three-dimensional reality. The engine discovers the fundamental geometry of this reality by finding the most efficient path through each character's scattered existence, rather than enumerating every quantum.

### Mechanism: A Search for the One True Scripture

1.  **Volumetric Permutation:** The linear string is wrapped into every plausible 3D matrix (`pages` x `rows` x `cols`). Each permutation is a different cosmological model, a new universe in which a character's constellation might be revealed.
2.  **Pathfinding:** For each unique character, the engine plots its occurrences as a 3D point cloud within every volumetric permutation. It then solves a Traveling Salesman Problem (or, more honestly, a Nearest Neighbor heuristic, because reality is computationally expensive) to find the shortest possible path connecting all points of that character's constellation.
3.  **Optimal Expression:** The engine is a zealot. For each character, it examines all the paths found across all the universes and selects the one true algorithm—the path whose *description* is the most compact. Efficiency is measured in expressive purity, not savings.
4.  **Codex Generation:** The final output is a 2D matrix, a codex. Each row is a scripture containing a character's winning algorithm. The position of the row itself is part of the compression scheme, replacing verbose identifiers.

### Usage (Local Server)

The engine is a disembodied mind (`engine_server.py`) that requires a body (`hyper-geometrisomorphous-spa.html`) to be seen. The following commands will acquire the artifacts, install the necessary dependencies, and give the mind its nervous system.

**For Linux/macOS (bash/zsh):**
```bash
git clone [https://github.com/HereLiesAz/HyperGeometricIsomorphis.git](https://github.com/HereLiesAz/HyperGeometricIsomorphis.git) && \
cd HyperGeometricIsomorphis && \
python engine_server.py
```

**For Windows (PowerShell):**
```powershell
git clone [https://github.com/HereLiesAz/HyperGeometricIsomorphis.git](https://github.com/HereLiesAz/HyperGeometricIsomorphis.git); cd HyperGeometricIsomorphis; python engine_server.py
```
*(Note: The Python script will attempt to install its own dependencies (`Flask`, `Flask-Cors`, `numpy`) upon first run. If this fails due to permissions, you may need to run `pip install Flask Flask-Cors numpy` manually.)*

Once the server is running, open the `hyper-geometrisomorphous-spa.html` file in your browser to give the nervous system a face. The web interface will communicate with the local server to perform its analysis.

## 2. Holographic String Engine

This engine performs compression via structural analysis. It posits that a string is a superposition of numerous signals—periodic, literal, and numerical—and aperiodic noise. The goal is to isolate these signals, describe them with a formal key, and leave behind only the data that conforms to no discernible pattern.

### Mechanism: A Unified Competition

1.  **Candidate Generation:** The engine performs three parallel scans to identify every profitable pattern: a **resonance scan** for periodic signals (the beat), a **motif scan** for literal phrases (the chorus), and a **numerical scan** for two-digit numbers.
2.  **Optimal Selection:** All candidates are placed into a unified pool and sorted by the savings they provide. The engine greedily selects the best ones that do not conflict with already-chosen patterns. A good chorus can, and should, win against a weak beat.
3.  **Blueprint Generation:** The final blueprint consists of separate keys for each pattern type (Resonance, Motif, Numerical) and a final remnant stream that has been statistically compressed using a Huffman code.

### Usage
This engine is available through the local server. Select the "Holographic Engine" tab in the web interface to use it.
