import numpy as np
import math
import json

class HyperGeometrisomorphous:
    """
    An engine that treats a string as a set of collapsed 3D point clouds (constellations),
    finding the single most efficiently expressed path for each character's constellation
    across all possible volumetric projections. The final blueprint is a 2D matrix (codex).
    """

    def __init__(self, text: str, update_callback=None):
        self.original_text = text
        self.length = len(text)
        self.log = update_callback or print

    def _get_volume_permutations(self):
        """Generates plausible 3D matrix dimensions (pages, rows, cols)."""
        permutations = set()
        # Limit the search space for performance.
        for pages in range(1, int(self.length**0.33) + 2):
            if self.length % pages == 0:
                area = self.length // pages
                for rows in range(1, int(area**0.5) + 2):
                    if area % rows == 0:
                        cols = area // rows
                        if pages * rows * cols == self.length:
                           permutations.add(tuple(sorted((pages, rows, cols))))
        if not permutations: permutations.add((1, 1, self.length))
        return sorted(list(permutations), key=lambda x: x[0]*x[1]*x[2])[:30]

    def _find_shortest_path(self, points):
        """
        Finds a 'good enough' path through a point cloud using the Nearest Neighbor heuristic.
        A true TSP solution is computationally intractable. This is an admission of reality.
        """
        if not points:
            return []
        
        path = [points.pop(0)]
        while points:
            last_point = path[-1]
            distances = [np.linalg.norm(np.array(last_point) - np.array(p)) for p in points]
            nearest_index = np.argmin(distances)
            path.append(points.pop(nearest_index))
        return path

    def _encode_path(self, path):
        """Encodes a path of 3D points into a compact series of vectors."""
        if len(path) < 2:
            return ""
        
        start_point = path[0]
        vectors = []
        for i in range(len(path) - 1):
            p1 = np.array(path[i])
            p2 = np.array(path[i+1])
            vectors.append(tuple(p2 - p1))
            
        # Further compress the vector list with run-length encoding
        if not vectors: return f"S{','.join(map(str, start_point))}"
        
        rle_vectors = []
        count = 1
        for i in range(1, len(vectors)):
            if vectors[i] == vectors[i-1]:
                count += 1
            else:
                rle_vectors.append(f"{vectors[i-1][0]},{vectors[i-1][1]},{vectors[i-1][2]}" + (f"*{count}" if count > 1 else ""))
                count = 1
        rle_vectors.append(f"{vectors[-1][0]},{vectors[-1][1]},{vectors[-1][2]}" + (f"*{count}" if count > 1 else ""))

        return f"S{','.join(map(str, start_point))}|" + "|".join(rle_vectors)

    def find_best_algorithm_for_char(self, char_to_find, permutations):
        """
        Generates all possible path algorithms for a single character and returns the best one.
        "Best" is defined as the one with the most compact descriptor string.
        """
        candidates = []
        all_indices = [i for i, char in enumerate(self.original_text) if char == char_to_find]
        if len(all_indices) < 1: return None

        for dims in permutations:
            pages, rows, cols = dims
            
            points = []
            for idx in all_indices:
                p = idx // (rows * cols)
                r = (idx % (rows * cols)) // cols
                c = idx % cols
                points.append((p, r, c))

            # Find the path and encode it
            path = self._find_shortest_path(points.copy())
            path_desc = self._encode_path(path)

            candidates.append({
                'char': char_to_find,
                'dims': dims,
                'desc': path_desc,
                'desc_len': len(path_desc)
            })

        # Return the candidate with the shortest description
        if candidates:
            return min(candidates, key=lambda x: x['desc_len'])
        return None

    def generate_blueprint(self):
        """The main orchestration method."""
        self.log("Phase 1: Universal Survey - Finding best path for each character...")
        permutations = self._get_volume_permutations()
        unique_chars = sorted(list(set(self.original_text)))
        
        winning_algorithms = {}
        for i, char in enumerate(unique_chars):
            self.log(f"  Finding most efficient scripture for '{char}' ({i+1}/{len(unique_chars)})...")
            best_algorithm = self.find_best_algorithm_for_char(char, permutations)
            if best_algorithm:
                winning_algorithms[char] = best_algorithm

        self.log("\nPhase 2: Codex Assembly - Building the 2D Matrix...")
        
        codex = []
        codex.append([f"len:{self.length}"])

        for char, algo in sorted(winning_algorithms.items()):
            codex.append([
                char, 
                f"{algo['dims'][0]}x{algo['dims'][1]}x{algo['dims'][2]}",
                algo['desc']
            ])

        # Serialize the 2D matrix into a single string
        serialized_codex = "ยง".join(["|".join(row) for row in codex])
        
        self.log("\nProcess Complete.")
        return serialized_codex

    @staticmethod
    def reconstruct(serialized_codex):
        """Reconstructs the original string from the serialized 2D matrix."""
        rows = [row.split('|') for row in serialized_codex.split('ยง')]
        
        metadata = rows[0]
        original_length = int(metadata[0].split(':')[1])
        
        algorithms = rows[1:]
        canvas = [''] * original_length # Use empty string as placeholder
        
        for algo_row in algorithms:
            char, dims_str, path_desc = algo_row
            pages, rows_dim, cols = map(int, dims_str.split('x'))
            
            # Decode the path
            path_parts = path_desc.split('|')
            start_point_str = path_parts[0][1:] # Remove 'S'
            
            if not start_point_str: continue # Skip if no points for this char

            start_point = np.array(list(map(int, start_point_str.split(','))))
            current_pos = start_point
            
            # Place the first point
            idx = int(current_pos[0]*rows_dim*cols + current_pos[1]*cols + current_pos[2])
            if idx < original_length: canvas[idx] = char
            
            # Follow the vectors
            if len(path_parts) > 1:
                for vector_str in path_parts[1:]:
                    if not vector_str: continue
                    parts = vector_str.split('*')
                    vector = np.array(list(map(int, parts[0].split(','))))
                    count = int(parts[1]) if len(parts) > 1 else 1
                    
                    for _ in range(count):
                        current_pos += vector
                        idx = int(current_pos[0]*rows_dim*cols + current_pos[1]*cols + current_pos[2])
                        if idx < original_length: canvas[idx] = char
                    
        return "".join(canvas)


if __name__ == "__main__":
    # Length is 120 = 3x5x8. 
    # 'a' is placed in a somewhat structured way, 'b' is random noise.
    base = list("b" * 120)
    indices_a = [0, 10, 22, 35, 45, 55, 61, 73, 85, 99, 110, 119]
    for i in indices_a: base[i] = 'a'
    test_string = "".join(base)

    print(f"Original String ({len(test_string)} chars):")
    print(test_string)
    print("-" * 30)

    isomorph = HyperGeometrisomorphous(test_string)
    compiled_blueprint = isomorph.generate_blueprint()

    print("\n--- COMPILED CODEX (Serialized) ---")
    print(f"\"{compiled_blueprint}\"")
    print("-" * 30)
    
    original_size = len(test_string)
    compressed_size = len(compiled_blueprint)
    
    print("\nSize Analysis:")
    print(f"  - Original: {original_size} characters")
    print(f"  - Compressed: {compressed_size} characters")
    if original_size > 0:
        ratio = (1 - compressed_size / original_size) * 100
        print(f"  - Reduction: {ratio:.2f}%")
        
    print("\nReconstructing from blueprint...")
    reconstructed_string = HyperGeometrisomorphous.reconstruct(compiled_blueprint)
    
    print("\nVerification:")
    print(f"  - Reconstructed String: \"{reconstructed_string}\"")
    print(f"  - Lossless: {reconstructed_string == test_string}")
